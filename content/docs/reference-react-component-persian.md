---
شناسه: واکنش-مؤلفه
عنوان: React.Component
طرح: اسناد
دسته: مرجع
پیوند همیشگی: docs / reag -onent.html
redirect_from:
  - "اسناد / مؤلفه-api.html"
  - "اسناد / مؤلفه-specs.html"
  - "اسناد / کامپوننت-مشخصات-ko-KR.html"
  - "اسناد / کامپوننت-مشخصات-zh-CN.html"
  - "نکات / UNSAFE_componentWillReceiveProps- باعث نمی شود بعد از نصب.html"
  - "نکات / dom-event-listeners.html"
  - "نکات / اولیه-ajax.html"
  - "نکات / استفاده-واکنش-با-دیگر-libraries.html"
---

این صفحه حاوی یک مرجع دقیق API برای تعریف کلاس مؤلفه React است. فرض بر این است که شما با مفاهیم اساسی React ، مانند [مؤلفه ها و Props] (/ اسناد / مؤلفه ها و props.html) ، و همچنین [State and Lifecycle] (/ اسناد / state-and-lifecycle.html) آشنا هستید. ) اگر اینگونه نیستید ، ابتدا آنها را بخوانید.

## بررسی {#overview

React به شما امکان می دهد تا مؤلفه ها را به عنوان کلاس یا توابع تعریف کنید. مؤلفه هایی که به عنوان کلاس تعریف شده اند در حال حاضر ویژگی های بیشتری را ارائه می دهند که در این صفحه با جزئیات توضیح داده شده اند. برای تعریف یک کلاس مؤلفه React ، باید «React.Component» را گسترش دهید:

جی
کلاس استقبال گسترش می یابد React.Component
  رندر کردن - ارائه کردن - دادن() {
    بازگشت <h1> سلام ، {this.props.name} </h1>؛
  }
}
`` `

تنها روشی که شما باید در زیر کلاس `React.Component` تعریف کنید [` rendering () `] (# ارائه) نامیده می شود. سایر روشهای توصیف شده در این صفحه اختیاری است.

** ما اکیداً مخالف ایجاد کلاسهای مؤلفه اصلی خود را توصیه می کنیم. ** در اجزای React ، [استفاده مجدد از کد در درجه اول از طریق ترکیب به جای وراثت انجام می شود] (/ اسناد / ترکیب-مقابل-ارثی.html).

> توجه:
>
> React شما را مجبور به استفاده از نحو کلاس ES6 نمی کند. اگر ترجیح می دهید از آن اجتناب کنید ، به جای آن می توانید از ماژول "ایجاد-واکنش-کلاس" یا یک انتزاع سفارشی مشابه استفاده کنید. برای یادگیری بیشتر به [استفاده از React بدون ES6] (/ اسناد / واکنش-بدون-es6.html) نگاهی بیندازید.

### چرخه حیات کامپوننت {# چرخه عمر-مؤلفه}

هر مؤلفه چندین "روش چرخه عمر" دارد که می توانید برای اجرای کد در زمان های خاص در فرایند ، آنها را نادیده بگیرید. ** می توانید از [این نمودار چرخه چرخه عمر] (http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/) به عنوان ورق تقلب استفاده کنید. ** در لیست زیر ، روش های معمول چرخه عمر به عنوان * * جسورانه **. بقیه آنها برای موارد استفاده نسبتاً نادر وجود دارد.

#### نصب {# قدم زدن}

وقتی نمونه ای از مؤلفه ها ساخته شده و وارد DOM می شوند این روش ها به ترتیب زیر گفته می شوند:

- [** `سازنده ()` **] (# سازنده)
- [`استاتیک getDerivedStateFromProps ()`] (# استاتیک-getderivedstatefromprops)
- [** `رندر ()` **] (# رندر)
- [** `բաղադրիչ DidMount ()` **] (# جزء جزء)

> توجه:
>
> این روش ها به عنوان میراث در نظر گرفته شده اند و شما باید از آنها جلوگیری کنید (/ blog / 2018/03/27 / update-on-async-rendering.html) در کد جدید:
>
> - [`UNSAFE_componentWillMount ()`] (# نا امن)

#### به روز رسانی {# روزآمد}

بروزرسانی می تواند در اثر تغییر در غرفه یا حالت ایجاد شود. وقتی یک جزء دوباره ساخته می شود ، این روش به ترتیب زیر خوانده می شود:

- [`استاتیک getDerivedStateFromProps ()`] (# استاتیک-getderivedstatefromprops)
- [`shouldComponentUpdate ()`] (# shouldcomponentupdate)
- [** `رندر ()` **] (# رندر)
- [`getSnapshotBeforeUpdate ()`] (# می شود عکس_فروش کنید)
- [** `onentDidUpdate () `**] (# مؤلفه_تصویر)

> توجه:
>
> این روش ها به عنوان میراث در نظر گرفته شده اند و شما باید از آنها جلوگیری کنید (/ blog / 2018/03/27 / update-on-async-rendering.html) در کد جدید:
>
> - [`UNSAFE_componentWillUpdate ()`] (# نا امن)
> - [`UNSAFE_componentWillReceiveProps ()`] (# نا امن)

#### ناگفتن {#unmounting

این روش هنگام حذف یک مؤلفه از DOM فراخوانی می شود:

- [** `کامپوننتWillUnmount ()` **] (# مؤلفه_مشکل)

#### کنترل خطا {# رسیدگی به خطا

این روش ها وقتی خطایی در هنگام رندر ، به روش چرخه چرخه چرخشی یا در سازنده هر یک از اجزای کودک وجود دارد ، خطا می شوند.

- [`استاتیک getDerivedStateFromError ()`] (# استاتیک- getderivedstatefromerror)
- [`բաղադրիչDidCatch ()`] (# مؤلفه_بسته)

### API های دیگر {# other-apis

هر مؤلفه همچنین برخی از API های دیگر را ارائه می دهد:

  - [`setState ()`] (# setstate)
  - [`forceUpdate ()`] (# forceupdate)

### خصوصیات کلاس {# کلاس_بسیار

  - [`defaultProps`] (# پیش فرض)
  - [`displayName`] (# نام نمایش)

### خصوصیات نمونه {# نمونه_خود}

  - [`props`] (# پروانه)
  - [`state`] (# ایالت)

* * *

## مرجع #reference

### روشهای چرخه زندگی متداول {# روشهای چرخه عمر معمول استفاده شده

روش های موجود در این بخش بخش اعظم موارد استفاده شما را با ایجاد قطعات React مواجه می سازد. ** برای یک مرجع بصری ، به [این نمودار چرخه عمر] مراجعه کنید (http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/). **

### `رندر ()` {#render}

`` `جاوا اسکریپت
رندر کردن - ارائه کردن - دادن()
`` `

روش "ارائه ()" تنها روش مورد نیاز در یک مؤلفه کلاس است.

در صورت فراخوانی ، باید "this.props" و "this.state" را بررسی کرده و یکی از انواع زیر را برگرداند:

- ** عناصر را واکنش دهید. ** به طور معمول از طریق [JSX] (/ اسناد / معرفی-jsx.html) ایجاد می شود. به عنوان مثال ، "<div />" و "<MyComponent />" عناصر React هستنددر دستورالعمل واکنش نشان دادن گره DOM یا مؤلفه دیگر تعریف شده توسط کاربر ، به ترتیب.
- ** آرایه ها و قطعات. ** به شما اجازه می دهد چندین عنصر را از رندر برگردانید. برای اطلاعات بیشتر به اسناد موجود در [قطعات] (/ docs / fragments.html) مراجعه کنید.
- ** پورتال **. به شما اجازه می دهیم کودکان را به یک زیربنای DOM متفاوت تبدیل کنید. برای اطلاعات بیشتر به اسناد موجود در [portalals] (/ docs / portalals.html) مراجعه کنید.
- ** رشته و اعداد. ** اینها به عنوان گره های متنی در DOM ارائه می شوند.
- ** بولیان یا "تهی" **. چیزی را ارائه ندهید. (بیشتر برای پشتیبانی از "آزمون بازگشت && <کودک />" الگوی ، که در آن "آزمون" بولی است وجود دارد.)

تابع `رندر () باید خالص باشد ، به این معنی که حالت کامپوننت را تغییر نمی دهد ، هر بار که فراخوانی می شود همان نتیجه را برمی گرداند و به طور مستقیم با مرورگر در تعامل نیست.

اگر شما نیاز به تعامل با مرورگر دارید ، به جای آن کارهای خود را در 'مؤلفDidMount () یا سایر روش های چرخه عمر انجام دهید. خالص نگه داشتن «رندر ()» باعث می شود مؤلفه ها راجع به آن راحت شوید.

> توجه داشته باشید
>
> "رندر ()" اگر ['mustComponentUpdate ()'] ((# shouldcomponentupdate) نادرست بازگردد) مورد استناد قرار نمی گیرد.

* * *

### `سازنده ()` {#constructor}

`` `جاوا اسکریپت
سازنده (غرفه ها)
`` `

** اگر حالت اولیه را تنظیم نکرده و روشهای لازم را به آن متصل نکنید ، نیازی به اجرای سازنده برای React ندارید. **

سازنده یک جزء React قبل از نصب نامیده می شود. هنگام اجرای سازنده برای یک زیر کلاس "React.Component" ، قبل از هر جمله دیگر باید "super (props)" تماس بگیرید. در غیر این صورت ، "این" پروانه ها در سازنده تعریف نمی شوند ، که می تواند منجر به اشکالات شود.

به طور معمول ، در سازنده React فقط برای دو هدف استفاده می شود:

* اولیه سازی [دولت محلی] (/ اسناد / چرخه دولت و چرخه زندگی.html) با اختصاص یک شیء به "this.state".
* اتصال به [کنترل کننده رویداد] (/ Docs / handling-Events.html) روشها به عنوان نمونه.

شما نباید در 'سازنده () `` setState () `** را صدا کنید. درعوض ، اگر مؤلفه شما نیاز به استفاده از حالت محلی دارد ، ** حالت اولیه را به "this.state" ** مستقیماً در سازنده اختصاص دهید:

جی
سازنده (غرفه ها) {
  فوق العاده (غرفه)؛
  // اینجا را صدا نکنید.
  this.state = {پیشخوان: 0}؛
  this.handleClick = this.handleClick.bind (این)؛
}
`` `

سازنده تنها مکانی است که باید بصورت مستقیم "this.state" را اختصاص دهید. در تمام روش های دیگر ، شما باید به جای آن از "this.setState ()" استفاده کنید.

از معرفی هرگونه عوارض جانبی یا اشتراک در سازنده خودداری کنید. برای کسانی که موارد استفاده را دارند ، به جای آن از `onentDidMount () استفاده کنید.

> توجه داشته باشید
>
> ** از کپی کردن پروانه ها به حالت خودداری کنید! این یک اشتباه رایج است: **
>
> `` js
> سازنده (غرفه) {
> فوق العاده (غرفه)؛
> // این کار را نکنید!
> this.state = {رنگ: props.color}؛
>}
> `` `
>
> مشکل این است که هر دو مورد غیر ضروری هستند (می توانید بجای آن مستقیم از این .props.color استفاده کنید) و اشکالات ایجاد می کند (به روزرسانی های مربوط به "رنگ" در حالت منعکس نمی شود).
>
> ** فقط در صورت تمایل به نادیده گرفتن به روزرسانی های تبلیغاتی ، از این الگوی استفاده کنید. ** در این حالت ، معقول است که قو را به نام "اولیهColor" یا "defaultColor" تغییر نام دهیم. سپس می توانید با تغییر دادن کلید داخلی خود ، یک مؤلفه را مجدداً تنظیم مجدد کنید (/ وبلاگ / 2018/06/07 / شما-احتمالاً-اصلاً-نیازی-مشتق شده-state.html # توصیه-کاملاً بدون کنترل در صورت لزوم - کامپوننت با یک کلید).
>
> [پست وبلاگ ما در مورد اجتناب از وضعیت مشتق شده] را بخوانید (/ وبلاگ / 2018/06/07 / شما-احتمالاً-اصلاً-نیازی-مشتق-state.html) ندارید تا در مورد آنچه باید انجام دهید اگر فکر می کنید در صورت وابستگی به وضعیت خاصی نیاز دارید ، مطالعه کنید. روی غرفه ها


* * *

### `جزءDidMount ()` {#componentdidmount

`` `جاوا اسکریپت
مؤلفه DidMount ()
`` `

`مؤلفهDidMount ()» بلافاصله پس از نصب يك جزء (درج شده در درخت) فراخوانده مي شود. اولیه سازی که به گره های DOM نیاز دارد باید به اینجا بروید. اگر شما نیاز به بارگذاری داده ها از نقطه انتهایی از راه دور دارید ، این مکان مناسب برای ارسال سریع درخواست شبکه است.

این روش مکان مناسبی برای تنظیم هرگونه اشتراک است. اگر چنین کاری را انجام دادید ، فراموش نکنید که در «مؤلفهWillUnmount ()» مشترک شوید.

شما ممکن است بلافاصله با "setState ()" تماس بگیرید با "onentDidMount () ". این یک رندر اضافی را ایجاد می کند ، اما این اتفاق خواهد افتاد قبل از اینکه مرورگر صفحه را به روز کند. این تضمین می کند که حتی اگر "رندر ()" در این حالت دو بار فراخوانده شود ، کاربر حالت میانی را مشاهده نمی کند. از این الگوی با احتیاط استفاده کنید زیرا اغلب باعث مشکلات عملکرد می شود. در بیشتر موارد ، شما می توانید به جای آن ، حالت اولیه را در "سازنده ()" اختصاص دهید. با این وجود می تواند برای مواردی مانند ماژول ها و نکات راهنمای ابزار لازم باشد که قبل از ارائه چیزی که به اندازه یا موقعیت آن بستگی دارد ، گره DOM را اندازه گیری کنید.

* * *

### `جزءDidUpdate ()` #componentdidupdate

`` `جاوا اسکریپت
کامپوننت DidUpdate (prevProps ، prevState ، عکس فوری)
`` `

بلافاصله پس از وقوع بروزرسانی ، «مؤلفهDidUpdate ()» فراخوانی می شود. این روش برای رندر اولیه فراخوانی نمی شود.

هنگامی که مؤلفه به روز شد ، از این به عنوان فرصتی برای کار با DOM استفاده کنید. این همچنین مکان خوبی برای انجام درخواست های شبکه تا زمانی که شما پیشنهادهای فعلی را با پیش بینی های قبلی مقایسه کنید (به عنوان مثال ممکن است یک درخواست شبکه در صورت عدم نیاز باشدغرفه ها تغییر نکردند)

جی
مؤلفه DidUpdate (prevProps)
  // استفاده معمولی (فراموش نکنید که مقایسه پیشنهادات):
  if (this.props.userID! == prevProps.userID)
    this.fetchData (this.props.userID)؛
  }
}
`` `

شما ** ممکن است بلافاصله با "setState ()" تماس بگیرید با "onentDidUpdate () "، اما توجه داشته باشید که ** باید در یک وضعیت ** مانند مثال بالا پیچیده شود ، یا شما یک حلقه نامحدود ایجاد خواهید کرد. همچنین باعث می شود مجدداً یک رندر اضافی ایجاد شود که در عین حال برای کاربر قابل مشاهده نیست ، اما می تواند بر عملکرد مؤلفه تأثیر بگذارد. اگر در حال تلاش برای "آینه کردن" برخی از حالت های موجود در سمت بالا هستید ، در عوض در نظر بگیرید که از قوطی استفاده کنید. اطلاعات بیشتر در مورد [چرا کپی کردن پروپوزالها به حالت اشکال ایجاد می کند] بخوانید (/ وبلاگ / 2018/06/07 / شما-احتمالاً-نیازی به-مشتق شده-state.html).

اگر مؤلفه شما چرخه حیات `getSnapshotBeforeUpdate ()` را اجرا کند (که نادر است) ، مقدار بازگشتی آن به عنوان یک پارامتر سوم «عکس فوری» به «مؤلفه DidUpdate ()» منتقل می شود. در غیر این صورت این پارامتر مشخص نخواهد شد.

> توجه داشته باشید
>
> "مؤلفه DidUpdate ()" اگر ['mustComponentUpdate () `]] (# shouldcomponentupdate) نادرست بازگردد ، مورد استفاده قرار نمی گیرد.

* * *

### `جزء WillUnmount ()` {#componentwillunmount

`` `جاوا اسکریپت
کامپوننتWillUnmount ()
`` `

قبل از آنكه يك جزء از آن جدا شود و از بين برود ، "مؤلفه WillUnmount ()" فراخوانده مي شود. هرگونه تمیز کردن لازم را در این روش انجام دهید ، مانند بی اعتبار کردن تایمر ، لغو درخواست شبکه یا تمیز کردن هرگونه اشتراک که در «مؤلفه DidMount ()» ایجاد شده است.

شما نباید با "setState ()` ** در "компонента WillUnmount ()" تماس بگیرید زیرا این مؤلفه هرگز دوباره ارائه نمی شود. هنگامی که نمونه ای از مؤلفه برداشته شد ، دیگر دوباره نصب نمی شود.

* * *

### روشهای چرخه عمر نادر استفاده می شود methods # روش_های چرخه عمر به ندرت استفاده می شود

روش های موجود در این بخش با موارد استفاده غیر معمول مطابقت دارد. آنها مدتی مفید هستند ، اما احتمالاً بیشتر اجزای شما به هیچکدام از آنها احتیاج ندارند. ** در صورت کلیک روی کادر "نمایش چرخه عمر کمتر" در بالای صفحه ، می توانید بیشتر روش های زیر را در [این نمودار چرخه عمر] مشاهده کنید (http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/). از آن. **


### `باید ComponentUpdate ()` sh #shouldcomponentupdate

`` `جاوا اسکریپت
باید ComponentUpdate (nextProps ، nextState)
`` `

از "mustComponentUpdate ()" استفاده کنید تا به React اطلاع دهید که آیا خروجی یک مؤلفه تحت تأثیر تغییر وضعیت فعلی یا حالت های پیشنهادی نیست. رفتار پیش فرض ارائه مجدد در هر تغییر حالت است و در اکثر موارد باید به رفتار پیش فرض تکیه کنید.

'mustComponentUpdate ()' قبل از ارائه در هنگام دریافت پیشنهادهای جدید یا وضعیت جدید ، فراخوانی می شود. پیش فرض به "درست". این روش برای رندر اولیه یا هنگام استفاده از "forceUpdate ()" نامیده نمی شود.

این روش فقط به عنوان ** [بهینه سازی عملکرد] (/ اسناد / بهینه سازی-عملکرد.html) وجود دارد. ** برای جلوگیری از رندر به آن اعتماد نکنید زیرا این می تواند به اشکالات منجر شود. ** به جای نوشتن «mustComponentUpdate ()» با دست با استفاده از [`PureComponent`] (/ docs / reag-api.html # reagpurecomponent) ** را در نظر بگیرید. `PureComponent` یک مقایسه کم عمق و مناسب با وضع موجود را انجام می دهد و این احتمال را می دهد که یک به روزرسانی لازم را جست و جو کنید.

اگر مطمئن هستید که می خواهید آن را به صورت دستی بنویسید ، می توانید "this.props" را با "nextProps" و "this.state" با "nextState" مقایسه کنید و "false" را برگردانید تا بگویید React ممکن است از این آپدیت صرف نظر شود. توجه داشته باشید که بازگشت "نادرست" باعث تغییر مجدد اجزای کودک در هنگام تغییر حالت * نمی شود.

ما توصیه نمی کنیم بررسی های برابری عمیق یا استفاده از "JSON.stringify ()" را در "mustComponentUpdate ()" استفاده کنید. بسیار ناکارآمد است و به عملکرد آسیب می رساند.

در حال حاضر ، اگر "mustComponentUpdate ()" false "بازگردد ، سپس [` UNSAFE_componentWillUpdate () `] (# unsafe_componentwillupdate) ، [` rendender () `] (# rendender) ، و [` բաղադրիչDidUpdate () `] (# جزء مورد استناد قرار نمی گیرد در آینده ممکن است React با "mustComponentUpdate ()" به عنوان یک اشاره به جای یک دستورالعمل دقیق رفتار کند ، و بازگشت "غلط" ممکن است بازنگری مجدد این مؤلفه باشد.

* * *

### `استاتیک getDerivedStateFromProps ()` {# استاتیک-getderivedstatefromprops}

جی
getDerivedStateFromProps استاتیک (غرفه ها ، حالت)
`` `

'getDerivedStateFromProps' درست قبل از فراخوانی با روش رندر ، چه در قسمت اولیه و چه در به روزرسانی های بعدی ، فراخوانی می شود. باید یک شیء را برای به روزرسانی وضعیت برگرداند ، یا تهی به چیزی برای بروزرسانی نکرد.

این روش برای [موارد استفاده نادر] (/ وبلاگ / 2018/06/07 / شما-احتمالاً-عدم نیاز-مشتق-state.html # زمان-به-استفاده-مشتق-حالت) وجود دارد) که در آن حالت به تغییر در بستگی دارد غرفه ها با گذشت زمان به عنوان مثال ، ممکن است برای اجرای یک مؤلفه "ترجمه" که فرزندان قبلی و بعدی خود را با یکدیگر مقایسه می کند ، تصمیم بگیرد که تصمیم بگیرند کدام یک از آنها را داخل بدن و خارج از آن تحریک کنند.

حالت درآمدی منجر به كلمات شفاهی می شود و تفكر اجزای شما را دشوار می كند.
[اطمینان حاصل کنید که با گزینه های ساده تر آشنا هستید:] (/ وبلاگ / 2018/06/07 / شما-احتمالاً-اصلاً-نیازی به اشتقاق-state.html)

* در صورت نیاز به انجام یک اثر جانبی ** (به عنوان مثال ، واکشی داده ها یا انیمیشن) در پاسخ به تغییر در عواملیs ، به جای آن ، از [`مؤلفهDidUpdate`] (# مؤلفه_خاص) استفاده کنید.

* اگر می خواهید ** فقط هنگامی که یک وسیله نقلیه تغییر می کند ، برخی از داده ها را دوباره محاسبه کنید ، [به جای آن از یک یاور حافظه سازی استفاده کنید] (/ وبلاگ / 2018/06/07 / شما-احتمالاً-dont-need-مشتق شده-state.html # چه-درباره-یادداشت).

* اگر می خواهید برخی از حالت ها را تغییر دهید. هنگامی که یک برنامه عواملی تغییر می کند ، یکی از مؤلفه های [کاملاً کنترل شده] (یا وبلاگ / 2018/06/07 / شما-احتمالاً-عدم نیاز-مشتق شده-وضعیت) را در نظر بگیرید. html # توصیه-کاملاً کنترل شده-جزء) یا [کاملاً کنترل نشده با یک کلید ”] (/ وبلاگ / 2018/06/07 / شما-احتمالاً-نیازی به-مشتق شده-shtet.html # توصیه-کاملاً بدون کنترل- به جای آن ، کامپوننت با یک کلید).

این روش به نمونه مؤلفه دسترسی ندارد. در صورت تمایل ، می توانید با استخراج توابع خالص غرفه های مؤلفه و خارج از تعریف کلاس از برخی کد ها بین `getDerivedStateFromProps ()» و سایر کلاس کلاس استفاده کنید.

توجه داشته باشید که این روش بدون در نظر گرفتن علت ، روی * رندر * اخراج می شود. این برخلاف "UNSAFE_componentWillReceiveProps" است ، که فقط در صورت آتش سوزی والدین باعث می شود که مجدد انجام شود و نه به عنوان نتیجه "setState" محلی.

* * *

### `getSnapshot پیشاپیش به روزرسانی ()` gets #getsnapshot پیشاپیش ate

`` `جاوا اسکریپت
getSnapshotBeforeUpdate (prevProps ، prevState)
`` `

'getSnapshotBeforeUpdate ()' درست قبل از متعهد شدن آخرین خروجی ارائه شده به مثال ، دعوت می شود. DOM این مؤلفه شما را قادر می سازد قبل از اینکه به طور بالقوه تغییر کند ، برخی از اطلاعات را از DOM (مثلاً موقعیت پیمایش) ضبط کنید. هر مقدار برگشتی توسط این چرخه عمر به عنوان یک پارامتر به "onentDidUpdate () "منتقل می شود.

این مورد استفاده معمولی نیست ، اما ممکن است در UI ها مانند یک موضوع گپ رخ دهد که باید موقعیت پیمایش را به روشی خاص انجام دهد.

مقدار عکس فوری (یا "null") باید برگردانده شود.

مثلا:

`embed: reag-مؤلفه-مرجع / گرفتن-عکس-قبل از بروزرسانی.js`

در مثالهای بالا خواندن ویژگی "scrollHeight" در "getSnapshotBeforeUpdate" مهم است زیرا ممکن است تاخیرهایی بین چرخه های فاز "رندر" (مانند "رندر") و "مرتکب" چرخه های عمر فاز (مانند `getSnapshotBeforeUpdate` و` բաղադրիչ DidUpdate .)

* * *

### مرزهای خطا {# مرزهای خطا

[مرزهای خطا] (/ docs / error-kufaries.html) مؤلفه هایی React هستند که خطاهای جاوا اسکریپت را در هر نقطه از درخت جزء فرزندشان می گیرند ، آن خطاها را وارد می کنند و به جای درخت مؤلفه که خراب می شوند ، UI fallback را نمایش می دهند. مرزهای خطا هنگام رندر ، در روش چرخه چرخه و در سازندگان کل درخت زیر آنها ، خطاها را می گیرند.

یک جزء کلاس در صورت تعریف یا (یا هر دو) روش های چرخه عمر `استاتیک getDerivedStateFromError () یا یا مؤلفهDidCatch ()` یک مرز خطا می شود. به روزرسانی حالت از این چرخه های عمر به شما امکان می دهد خطای جاوا اسکریپت غیرقابل کنترل را در درخت زیر ضبط کنید و یک رابط کاربری ناخواسته نشان دهید.

فقط از مرزهای خطا برای بازیابی از استثنائات غیر منتظره استفاده کنید. ** سعی نکنید از آنها برای جریان کنترل استفاده کنید. **

برای اطلاعات بیشتر ، به [* رسیدگی به خطا در React 16 *] (/ وبلاگ / 2017/07/26 / خطای-کنترل-در-واکنش-16.html) مراجعه کنید.

> توجه داشته باشید
>
> مرزهای خطا فقط در اجزای ** در زیر ** آنها را در درخت خطا می گیرند. یک خطای خطا نمی تواند خطایی را در درون خود داشته باشد.

### `استاتیک getDerivedStateFromError ()` {# استاتیک-getderivedstatefromerror}
`` `جاوا اسکریپت
استاتیک getDerivedStateFromError (خطا)
`` `

این چرخه عمر پس از پرتاب خطایی توسط یک مولفه فرودست فراخوانی می شود.
خطایی را که به عنوان یک پارامتر انداخته شده دریافت می کند و باید یک مقدار را برای به روزرسانی حالت بازگشت دهد.

`` `js -10 7-10،13-16
کلاس ErrorBoundary React.Component ends
  سازنده (غرفه ها) {
    فوق العاده (غرفه)؛
    this.state = {hasError: false}؛
  }

  استاتیک getDerivedStateFromError (خطا) {
    // وضعیت را به روز کنید تا رندر بعدی UI برگشتی را نشان دهد.
    Return {hasError: true؛
  }

  رندر کردن - ارائه کردن - دادن() {
    if (this.state.hasError) {
      // شما می توانید هر رابط کاربر بازگشتی سفارشی ارائه دهید
      بازگشت <h1> مشکلی پیش آمد. </h1>؛
    }

    این را برگردانید .props.children؛
  }
}
`` `

> توجه داشته باشید
>
> 'getDerivedStateFromError ()' در مرحله "ارائه" فراخوانی می شود ، بنابراین عوارض جانبی مجاز نیستند.
برای کسانی که موارد استفاده را دارند ، در عوض از `مؤلفه () استفاده کنید.

* * *

### `جزءDidCatch ()` {#componentdidcatch

`` `جاوا اسکریپت
مؤلفه
`` `

این چرخه عمر پس از پرتاب خطایی توسط یک مولفه فرودست فراخوانی می شود.
این دو پارامتر را دریافت می کند:

1. `خطا - خطایی که پرتاب شد.
2. `اطلاعات` - یک شیء با کلید` مؤلفه استک` حاوی [اطلاعات مربوط به کدام مؤلفه خطا را پرتاب می کند] (/ اسناد / خطا-مرزها .html # مؤلفه-پشته-ردیابی).


در مرحله "مرتكب كردن" "مؤلفه (كامپيوتر)" () ناميده مي شود ، بنابراين عوارض جانبي مجاز است.
باید برای مواردی مانند خطاهای ورود به سیستم استفاده شود:

`` `js 12-19}
کلاس ErrorBoundary React.Component ends
  سازنده (غرفه ها) {
    فوق العاده (غرفه)؛
    this.state = {hasError: false}؛
  }

  استاتیک getDerivedStateFromError (خطا) {
    // وضعیت را به روز کنید تا رندر بعدی UI برگشتی را نشان دهد.
    Return {hasError: true؛
  }

  کامپونentDidCatch (خطا ، اطلاعات) {
    // مثال "basicStack":
    // در ComponentThatThrows (ایجاد شده توسط برنامه)
    // در ErrorBoundary (ایجاد شده توسط برنامه)
    // in div (ایجاد شده توسط برنامه)
    // در برنامه
    logComponentStackToMyService (info.componentStack)؛
  }

  رندر کردن - ارائه کردن - دادن() {
    if (this.state.hasError) {
      // شما می توانید هر رابط کاربر بازگشتی سفارشی ارائه دهید
      بازگشت <h1> مشکلی پیش آمد. </h1>؛
    }

    این را برگردانید .props.children؛
  }
}
`` `

> توجه داشته باشید
>
> در صورت بروز خطا ، می توانید با فراخوانی 'setState' UI برگشتی را با'onentDidCatch () ارائه دهید ، اما این در نسخه بعدی کاهش می یابد.
> از "استاتیک getDerivedStateFromError ()" استفاده کنید تا به جای آن بتوانید عملکرد رندر را به کار بگیرید.

* * *

### روش های چرخه زندگی میراث {# میراث-چرخه عمر-روش

روش های چرخه عمر زیر به عنوان "میراث" مشخص شده است. آنها هنوز هم کار می کنند ، اما ما توصیه نمی کنیم از آنها در کد جدید استفاده کنید. می توانید اطلاعات بیشتری در مورد مهاجرت به دور از روش های چرخه زندگی میراث در [این پست وبلاگ] (/ وبلاگ / 2018/03/27 / بروزرسانی-on-async-rendering.html) کسب کنید.

### `UNSAFE_componentWillMount ()` {#unsafe_componentwillmount

`` `جاوا اسکریپت
UNSAFE_componentWillMount ()
`` `

> توجه داشته باشید
>
> این چرخه عمر پیش از این به عنوان "مؤلفه WillMount" نامگذاری شده بود. این نام تا نسخه 17 به کار خود ادامه خواهد داد. از کد [`تغییر نام ناامن-چرخه عمر] (https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) استفاده کنید.

'UNSAFE_componentWillMount ()' درست قبل از وقوع نصب فراخوانی شده است. قبل از "رندر ()" گفته می شود ، بنابراین همزمان با استفاده از "setState ()" در این روش ، یک رندر اضافی ایجاد نمی شود. به طور کلی ، ما توصیه می کنیم به جای برای تنظیم حالت ، از "سازنده ()" استفاده کنید.

از معرفی هرگونه عوارض جانبی یا اشتراک در این روش خودداری کنید. برای کسانی که موارد استفاده را دارند ، به جای آن از `onentDidMount () استفاده کنید.

این تنها روش چرخه عمر است که به رندر سرور گفته می شود.

* * *

### `UNSAFE_componentWillReceiveProps ()` {#unsafe_componentwillreceiveprops}

`` `جاوا اسکریپت
UNSAFE_componentWillReceiveProps (nextProps)
`` `

> توجه داشته باشید
>
> این چرخه عمر پیش از این به عنوان "مؤلفه WillReceiveProps" نامگذاری شده بود. این نام تا نسخه 17 به کار خود ادامه خواهد داد. از کد [`تغییر نام ناامن-چرخه عمر] (https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) استفاده کنید.

> توجه:
>
> استفاده از این روش چرخه عمر اغلب منجر به اشکالات و ناهماهنگی ها می شود
>
> * در صورت نیاز به ایجاد یک اثر جانبی ** (به عنوان مثال ، واکشی داده ها یا انیمیشن) در پاسخ به تغییر در غرفه ها ، به جای آن از [`مؤلفه اصلی DidUpdate`] (# جزء_کامپوزیت) استفاده کنید.
> * اگر از "مؤلفهWillReceiveProps" برای ** دوباره محاسبه برخی از داده ها استفاده می کنید ، فقط در صورت تغییر در یک پیشخوان ** ، [به جای آن از یک یاور حافظه سازی استفاده کنید] (/ وبلاگ / 2018/06/07 / شما-احتمالاً-نیازی به مشتق نیست -state.html # چه-درمورد یادداشت).
> * اگر از "مؤلفهWillReceiveProps" برای استفاده از "تنظیم مجدد" برخی حالت استفاده می کنید ، هنگام استفاده از برنامه اضافه می کند ، یا یک جزء [کاملاً کنترل شده] را در نظر بگیرید (/ وبلاگ / 2018/06/07 / احتمالاً شما اصلاً نیازی ندارید) مشتق شده-state.html # توصیه-کاملاً کنترل شده-مؤلفه) یا [کاملاً کنترل نشده با یک 'کلید'] (/ وبلاگ / 2018/06/07 / شما-احتمالاً-اصلا-نیازی به-مشتق شده-shtet.html # توصیه- به جای آن ، کاملاً کنترل نشده-کامپوننت با یک کلید).
>
> برای سایر موارد استفاده ، [دنبال توصیه های این پست وبلاگ در مورد وضعیت مشتق شده] (/ وبلاگ / 2018/06/07 / شما-احتمالاً-dont-need-مشتق شده-state.html).

'UNSAFE_componentWillReceiveProps ()' قبل از دریافت یک مؤلفه نصب شده ، گزاره های جدیدی را فراخوانی می کند. اگر شما نیاز دارید که دولت را در پاسخ به تغییرات پیش فرض (به عنوان مثال ، برای تنظیم مجدد آن) به روز کنید ، می توانید "this.props" و "nextProps" را مقایسه کرده و با استفاده از "this.setState ()" در این روش انتقال حالت را انجام دهید.

توجه داشته باشید که اگر یک مؤلفه والدین باعث شود مجدد عنصر شما مجدداً ارائه شود ، این روش حتی اگر پیش بینی ها تغییر نکرده باشد ، خوانده می شود. اگر فقط می خواهید تغییرات را کنترل کنید ، مقادیر فعلی و بعدی را با یکدیگر مقایسه کنید.

React با "غرفه های اولیه" در هنگام نصب (# نصب) با "UNSAFE_componentWillReceiveProps ()" تماس نمی گیرد. این تنها در صورتی فراخوانی می شود که برخی از پیشنهادات مؤلفه ممکن است به روز شود. فراخوانی "this.setState ()" به طور کلی باعث نمی شود "UNSAFE_componentWillReceiveProps ()".

* * *

### `UNSAFE_componentWillUpdate ()` {#unsafe_componentwillupdate

`` `جاوا اسکریپت
UNSAFE_componentWillUpdate (nextProps ، nextState)
`` `

> توجه داشته باشید
>
> این چرخه عمر پیش از این به عنوان "مؤلفه WillUpdate" نامگذاری شده بود. این نام تا نسخه 17 به کار خود ادامه خواهد داد. از کد [`تغییر نام ناامن-چرخه عمر] (https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) استفاده کنید.

'UNSAFE_componentWillUpdate ()' درست قبل از ارائه هنگام دریافت پیشنهادات یا وضعیت جدید ، فراخوانی می شود. قبل از بروزرسانی ، از این به عنوان فرصتی برای انجام آماده سازی استفاده کنید. این روش برای رندر اولیه فراخوانی نمی شود.

توجه داشته باشید که شما نمی توانید با "this.setState ()" اینجا تماس بگیرید. و همچنین شما نباید کارهای دیگری انجام دهید (مثلاً اعزام یک عملکرد Redux) که می تواند یک جزء React را به روز کند قبل از بازگشت "UNSAFE_componentWillUpdate ()".

معمولبله ، این روش را می توان با "onentDidUpdate () "جایگزین کرد. اگر در این روش از DOM می خوانید (مثلاً برای ذخیره موقعیت پیمایش) ، می توانید آن منطق را به "getSnapshotBeforeUpdate ()" منتقل کنید.

> توجه داشته باشید
>
> "UNSAFE_componentWillUpdate ()" اگر ["mustComponentUpdate ()"] (# shouldcomponentupdate) نادرست بازگردد ، مورد استفاده قرار نمی گیرد.

* * *

## API های دیگر {# other-apis-1

برخلاف روشهای چرخه عمر بالا (که React شما را فرا می خواند) ، روشهای زیر روشهایی هستند که * شما می توانید از طریق اجزای خود تماس بگیرید.

فقط دو مورد وجود دارد: `setState ()» و «forceUpdate ()».

### `setState ()` {#setstate

`` `جاوا اسکریپت
setState (بروزرسانی [، پاسخ به تماس])
`` `

`setState () تغییراتی را در حالت کامپوننت اعمال می کند و به React می گوید که این مؤلفه و فرزندان آن باید با وضعیت به روز شده مجدداً ارائه شوند. این اولین روش شما برای به روزرسانی رابط کاربری در پاسخ به گیرندگان رویداد و پاسخ های سرور است.

به جای یک دستور فوری برای به روزرسانی مؤلفه ، به عنوان "درخواست * به عنوان" درخواست * فکر کنید. برای عملکرد بهتر درک شده ، React ممکن است آن را به تاخیر اندازد و سپس چندین مؤلفه را با یک پاس واحد به روز کند. React تضمین نمی کند که تغییرات دولت بلافاصله اعمال می شود.

`setState ()` همیشه مؤلفه را بلافاصله به روز نمی کند. ممکن است بروزرسانی را بعداً دسته بندی یا به تعویق انداخته باشد. این باعث می شود خواندن "this.state" درست پس از فراخوانی "setState ()" یک خطای احتمالی در نظر گرفته شود. درعوض ، از 'مؤثرDidUpdate' یا یک پاسخ به تماس برگشتی 'setState' ('setState (بروزرسانی ، پاسخ به تماس))' استفاده کنید ، که هر دو پس از اعمال به روزرسانی در آتش سوزی تضمین شده اند. اگر نیاز دارید که حالت را بر اساس حالت قبلی تنظیم کنید ، در زیر استدلال "Updater" را در زیر بخوانید.

"setState ()" همیشه به ارائه مجدد منجر می شود ، مگر اینکه "mustComponentUpdate ()" false "بازگردد. اگر اشیاء قابل تغییر استفاده می شوند و منطق ارائه شرط نمی تواند در "mustComponentUpdate ()" اجرا شود ، با "setState ()" فراخوانی می شود تنها در شرایطی که حالت جدید با حالت قبلی متفاوت است از تجدیدنظرهای غیر ضروری اجتناب کنید.

اولین آرگومان یک تابع `بروزرسانی با امضا است:

`` `جاوا اسکریپت
(state، props) => stateChange
`` `

"دولت" در زمان اعمال تغییر ، مرجعی به حالت مؤلفه است. نباید مستقیماً جهش یابد. در عوض ، تغییرات باید با ساختن یک شی جدید بر اساس ورودی از "حالت" و "props" ارائه شوند. به عنوان مثال ، فرض کنید می خواهیم یک مقدار را در حالت "props.step" افزایش دهیم:

`` `جاوا اسکریپت
this.setState ((حالت ، پیشنهادات) =>
  Return {counter: state.counter + props.step}؛
})؛
`` `

هر دو حالت "حالت" و "props" دریافت شده توسط عملکرد Updater تضمین می شوند که به روز هستند. خروجی به روزرسانی بطور کم عمق با "حالت" ادغام می شود.

پارامتر دوم "setState ()" یک عملکرد برگشتی اختیاری است که پس از اتمام "setState" و اجرای مجدد آن کامپوننت ، اجرا خواهد شد. به طور کلی توصیه می کنیم در عوض برای چنین منطق از "مؤلفهDidUpdate ()" استفاده کنید.

شما می توانید به صورت اختیاری یک شیء را به عنوان اولین آرگومان به جای یک تابع به "setState ()" منتقل کنید:

`` `جاوا اسکریپت
setState (stateChange [، پاسخ به تماس])
`` `

این کار ترکیب کمتری از "stateChange" را در حالت جدید ، به عنوان مثال ، برای تنظیم مقدار کالای سبد خرید انجام می دهد:

`` `جاوا اسکریپت
this.setState ({مقدار: 2})
`` `

این شکل از 'setState ()' نیز ناهمزمان است و ممکن است چندین تماس در طی همان چرخه با هم جمع شوند. به عنوان مثال ، اگر در همان چرخه سعی کنید مقدار یک مورد را بیش از یک بار افزایش دهید ، این معادل آن خواهد بود:

`` `javaScript
Object.assign (
  previousState ،
  {مقدار: state.quantity + 1} ،
  {مقدار: state.quantity + 1} ،
  ...
)
`` `

تماسهای بعدی مقادیر از تماسهای قبلی را در همان چرخه غلبه می کنند ، بنابراین مقدار فقط یک بار افزایش می یابد. اگر حالت بعدی به وضعیت فعلی بستگی دارد ، توصیه می کنیم به جای آن از فرم عملکرد تکمیل کننده استفاده کنید:

جی
this.setState ((حالت) =>
  Return {مقدار: state.quantity + 1}؛
})؛
`` `

برای جزئیات بیشتر ، مراجعه کنید به:

* [دولت و راهنمای چرخه عمر] (/ اسناد / دولت و چرخه زندگی.html)
* [در عمق: چه موقع و چرا تماس های setState () `خسته می شوند؟] (https://stackoverflow.com/a/48610973/458193)
* [در عمق: چرا 'this.state' بلافاصله به روز نمی شود؟] (https://github.com/facebook/react/issues/11527#issuecomment-360199710)

* * *

### `forceUpdate ()` {#forceupdate

`` `جاوا اسکریپت
کامپوننت.forceUpdate (پاسخ به تماس)
`` `

به طور پیش فرض ، هنگامی که حالت یا پیشنهادهای اجزای شما تغییر کند ، مؤلفه شما دوباره ارائه می شود. اگر روش "ارائه ()" شما به برخی داده های دیگر بستگی دارد ، می توانید با فراخوانی "forceUpdate ()" به بازخوانی مجدد بگویید.

فراخواندن "forceUpdate ()" باعث می شود که "رندر" () "در مؤلفه فراخوانده شود ، با رد شدن از" mustComponentUpdate () ". این روش های طبیعی چرخه چرخه را برای اجزای کودک ، از جمله روش "mustComponentUpdate ()" برای هر کودک تحریک می کند. در صورت تغییر نشانگر ، React فقط DOM را به روز می کند.

به طور معمول باید سعی کنید از استفاده از "forceUpdate ()" جلوگیری کنید و فقط از "this.props" و "this.state" در "رندر ()" بخوانید.

* * *

## ویژگی های کلاس {# class-properties-1

### `defaultProps` {#defaultprops}

'defaultProps' را می توان به عنوان یک ویژگی در کلاس کامپوننت تعریف کرد ، تا پیش بینی های پیش فرض برای کلاس تنظیم شود. این مورد برای غرفه های نامشخص استفاده می شود ، اما برای غرفه های پوچ نیست. مثلا:

جی
کلاس CustomButton React.Component ends
  // ...
}

CustomButton.defaultProps = {
  رنگ آبی'
؛
`` `

اگر "props.color" ارائه نشود ، به طور پیش فرض روی "blue" قرار می گیرد:

جی
  رندر کردن - ارائه کردن - دادن() {
    بازگشت <CustomButton />؛ // props.color به رنگ آبی تنظیم می شود
  }
`` `

اگر "props.color" تنظیم شود ، تهی خواهد ماند:

جی
  رندر کردن - ارائه کردن - دادن() {
    بازگشت <CustomButton color = {null} />؛ // props.color تهی خواهد ماند
  }
`` `

* * *

### `displayName` #displayname}

رشته "displayName" در اشکال زدایی پیام ها استفاده می شود. معمولاً نیازی به تنظیم صریح آن نیست زیرا از نام تابع یا کلاس است که مؤلفه را تعریف می کند استنباط می شود. اگر می خواهید نام دیگری را برای اهداف اشکال زدایی نشان دهید یا وقتی یک مؤلفه مرتبه بالاتر ایجاد می کنید ، آن را صریحاً تنظیم کنید ، به [بسته بندی نام صفحه برای اشکال زدایی آسان] ((اسناد / اسناد بالاتر از اجزای مرتبه بالاتر) مراجعه کنید. کنوانسیون-بسته بندی-نمایش-نام-نام-آسان برای اشکال زدایی) برای جزئیات.

* * *

## ویژگیهای نمونه {# نمونه-خصوصیات-1}

### `props`` #props

'this.props' حاوی رأی هایی است که توسط تماس گیرنده این مؤلفه تعریف شده است. برای آشنایی با پیشنهادها به [مؤلفه ها و Props] (/ اسناد / مؤلفه ها و props.html) مراجعه کنید.

به طور خاص ، "this.props.children" یک شیرجه مخصوص است که به طور معمول توسط برچسب های کودک در عبارت JSX تعریف می شود نه در خود تگ.

### `دولت` {# ایستگاه

دولت حاوی داده های خاص برای این مؤلفه است که ممکن است با گذشت زمان تغییر کند. حالت تعریف شده توسط کاربر است و باید یک شی ساده JavaScript باشد.

اگر مقداری برای رندر یا جریان داده ها استفاده نمی شود (برای مثال ، شناسه تایمر) ، لازم نیست آن را در حالت قرار دهید. این مقادیر را می توان به عنوان مثال در قسمت جزء تعریف کرد.

برای کسب اطلاعات بیشتر در مورد ایالت به [State and Lifecycle] (/ docs / state-and-lifecycle.html) مراجعه کنید.

هرگز "this.state" را مستقیماً جهش ندهید ، زیرا فراخوانی "setState ()" پس از آن ممکن است جایگزین جهش ساخته شده شما شود. با "این" حالت رفتار کنید انگار غیرقابل تغییر است.
