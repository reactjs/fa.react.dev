---
id: react-dom
title: ReactDOM
layout: docs
category: Reference
permalink: docs/react-dom.html
---

<p dir="rtl">
اگر React را با استفاده از `<script>` بارگیری می کنید، این API های سطح بالا در همه جا بر روی **ReactDOM** در دسترس هستند. اگر از ES6 با npm استفاده می کنید، می توانید `import ReactDOM from 'react-dom'` را وارد کنید. اگر از ES5 با npm استفاده می کنید نیز `var ReactDOM = require('react-dom')` را بنویسید.
</p>
  
<h2 dir="rtl">بررسی اجمالی {#overview}</h2>
<p dir="rtl">
بسته `react-dom` روش هایی خاص برای مدیریت و کار با پرونده را فراهم می کند که می تواند در بالاترین سطح برنامه ها استفاده شود و به عنوان یک راه برای جلوگیری از استفاده از ماژول `React` است.
بیشتر اجزای برنامه شما نیازی به استفاده از این ماژول ندارد.
</p>

- [`render()`](#render)
- [`hydrate()`](#hydrate)
- [`unmountComponentAtNode()`](#unmountcomponentatnode)
- [`findDOMNode()`](#finddomnode)
- [`createPortal()`](#createportal)

<h3 dir="rtl">پشتیبانی مرورگر {#browser-support}</h3>
<p dir="rtl">
ری اکت از کلیه مرورگرهای محبوب، از جمله Internet Explorer 9 و بالاتر پشتیبانی می کند، اگرچه [چند پیش نیاز دارد](/docs/javascript-Environment-Requires.html) تا برای مرورگرهای قدیمی مانند IE 9 و IE 10 به خوبی عمل کند.

> نکته
>
> ما از مرورگرهای قدیمی كه از روشهای ES5 پشتیبانی نمی كنند پشتیبانی نمی كنیم، اما شما ممكن است متوجه شوید که در صورتی که برنامه شما شامل پیش نیاز هایی مانند [es5-shim و es5-sham](https://github.com/es-shims/es5-shim) باشد برنامه های شما در مرورگرهای قدیمی نیز به خوبی كار کند. اگر تصمیم دارید این را انتخاب کنید، مسئولیت آن با خودتان است.
</p>

<h2 dir="rtl">ارجاع {#reference}</h2>

<h3 dir="rtl">`render()` {#render}</h3>

```javascript
ReactDOM.render(element, container[, callback])
```
<p dir="rtl">
یک عنصر React را به DOM در ظرف قرار دهید و یک [مرجع](/docs/more-about-refs.html) به مؤلفه (یا برگشت مقدار `null` برای [اجزای بی تاب](/docs/components-and-props.html#function-and-class-components)) بازگردانی کنید.

اگر عنصر React قبلاً در ظرف قرار داده شده باشد، این یک به روزرسانی را روی آن انجام می دهد و فقط در صورت لزوم DOM را تغییر می دهد تا آخرین عنصر React را منعکس کند.

اگر مقدار پاسخ که یک مقدار اختیاری است را ارائه داده باشید، پس از ارائه یا به روزرسانی مؤلفه، اجرا خواهد شد.
 

> نکته:
> `ReactDOM.render()` محتوای نود container که به داخل آن می‌فرستید را کنترل می کند. هنگامی که برای اولین بار فراخوانی می‌شود هر المنتی که داخلش باشد جایگزین می‌شود. ولی در سایر فراخوانی‌ها برای بهینه بودن به‌روزرسانی از الگوریتم اختلاف‌یاب React استفاده می‌شود (React’s DOM diffing algorithm).
>
> `ReactDOM.render()` نود اصلی را تغییر نمیدهد (فقط بچه‌های container را تغییر می‌دهد). شاید ممکن باشد که کامپوننتی را درون نودی که قبلا وجود داشته وارد کرد بدون اینکه نیاز به بازنویسی نودهای زیر شاخه(children) باشد.
>
> `ReactDOM.render()` در حال حاضر یک ارجاع از ریشه بدل(instance) `ReactComponent` برمی‌گرداند. با این حال با این حال استفاده از این مقدار برگشتی نوعی میراث است و باید از آن پرهیز شود زیرا در ورژن‌های آینده React شاید برخی کامپوننت‌ها در گاهی اوقات ناهمگام رندر شوند.اگر شما به مرجع بدل ریشه `ReactComponent` نیاز داشتید، بهترین راه حل آن است که یک [callback ref](/docs/more-about-refs.html#the-ref-callback-attribute) به ریشه المنت وصل کنید.
>
> استفاده از `ReactDOM.render()` برای hydrate کردن رندر شدن container سمت سرور منسوخ شده است و در ورژن ۱۷ React پاک خواهد شد. به جای آن از [`()hydrate`](#hydrate) استفاده کنید.
</p>

* * *

<h3 dir="rtl">`hydrate()` {#hydrate}</h3>

```javascript
ReactDOM.hydrate(element, container[, callback])
```

<p dir="rtl">
مثل [`()render`](#render) است، ولی برای hydrate کردن یک container که محتوای HTML آن توسط [`ReactDOMServer`](/docs/react-dom-server.html) رنده شده است استفاده می‌شود. React تلاش می‌کند تا event listenerهایی به (markups)نشانه‌گذاری‌های موجود متصل کند.

ری اکت انتظار دارد که محتوای ارائه شده بین سرور و کلاینت یکسان باشد. این می تواند اختلافات در متن را برطرف کند، اما باید ناسازگاری ها را با اشکال در نظر بگیرید و آنها را برطرف کنید. در حالت توسعه، React در مورد عدم تطابق هشدار می دهد. هیچ تضمینی وجود ندارد که اختلاف ویژگی ها در صورت عدم تطابق در آنها برطرف شود. این امر به دلایل عملکرد بسیار مهم است زیرا در اکثر برنامه ها، عدم تطابق نادر است، بنابراین اعتبار و اهمیت دادن به همه نشانه گذاری ها بسیار گران قیمت است.

اگر ویژگی و عنصر متن یک عنصر به طور اجتناب ناپذیری بین سرور و مشتری متفاوت باشد (برای مثال ، یک timestamp)، شما می توانید با اضافه کردن "suppressHydrationWarning = {true" به این عنصر هشدار را ساکت کنید. این درنظر گرفته شده است که یک دریچه فرار باشد. بیش از حد از آن استفاده نکنید. اگر محتوای متن نباشد، React تلاش نخواهد کرد تا آنرا پیکربندی کند، بنابراین ممکن است تا به روزرسانیهای بعدی متناقض بماند.


اگر نیاز دارید تا از عمد چیز متفاوتی سمت سرور یا کاربر رندر کنید، می‌توانید از روش رندر کردن دو-گذری استفاده کنید. کامپوننت‌هایی که چیز متفاوتی سمت کاربر رندر می‌کنند می‌توانند stateای شبیه به `this.state.isClient` را بخوانند، که می‌توانید آن را در `componentDidMount()` برابر `true` قرار دهید. به این طریق در گذر اولیه رندر، همان محتوای سمت سرور رندر می‌شود، از عدم تطابق جلوگیری می‌شود، ولی یک گذر همگام درست بعد از hydration اتفاق می‌افتد. توجه کنید که در این روش کامپوننت‌های شما کم سرعت می‌شوند زیرا باید دوبار رندر شوند، پس با دقت استفاده کنید.

نسبت به اتصال ضعیف کاربر توجه داشته باشید. کد JavaScript می‌تواند خیلی دیرتر از HTML اولیه رندر شود، پس اگر چیز متفاوتی در گذر فقط-کاربر رندر کنید، انتقال می‌تواند نامطلوب باشد. گرچه، اگر به خوبی اجرا شود، می‌تواند برای رندر شدن "shell" نرم‌افزار روی سرور مفید باشد، و فقط چند ابزارک سمت کاربر را نشان می‌دهد. برای اینکه بدانید این کار بدون اینکه درچار مشکل تطابق شوید چطور انجام می‌شود، به توضیحات پاراگراف قبلی مراجعه کنید.
</p>

* * *

<h3 dir="rtl">`unmountComponentAtNode()` {#unmountcomponentatnode}</h3>

```javascript
ReactDOM.unmountComponentAtNode(container)
```

<p dir="rtl">
یک مؤلفه React نصب شده را از DOM جدا کرده و بررسی کننده رویداد و وضعیت آن را تمیز کنید. اگر هیچ مؤلفه ای در ظرف نصب نشده باشد، فراخوانی این عملکرد هیچ کاری نمی کند. این عملکرد مقدار صحیح را برمیگرداند اگر مؤلفه برچیده شود و در صورت عدم وجود مؤلفه ای مقدار "نادرست" را می گرداند.
</p>

* * *

<h3 dir="rtl">`findDOMNode()` {#finddomnode}</h3>
<p dir="rtl">

> توجه داشته باشید:
> 
> متد findDOMNode یک دریچه فرار است که برای دسترسی به گره DOM استفاده می شود. در بیشتر موارد، استفاده از این دریچه فرار از آن منع می شود زیرا انتزاع مؤلفه را سوراخ می کند. [این در "StrictMode" منسوخ شده است.](/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage)
</p>

```javascript
ReactDOM.findDOMNode(component)
```

<p dir="rtl">
اگر این مؤلفه در DOM نصب شده باشد ، این عنصر DOM مرورگر بومی را برمی گرداند. این روش برای خواندن مقادیر خارج از DOM مانند مقادیر شکل فرم و انجام اندازه گیری DOM مفید است. **در بیشتر موارد، شما می توانید یک گره به DOM متصل کنید و از استفاده از "findDOMNode" خودداری کنید.**

هنگامی که یک جزء را بصورت "null" یا "false"و findDOMNode ظاهر می شود و `null` را برمی گرداند. وقتی یک جزء به عنوان یک رشته ظاهر می شود `findDOMNode` یک عنصر متنی را که شامل متن است برمیگرداند.
همانطور که از React 16، یک مؤلفه می تواند قطعه ای را به همراه چند فرزند برگرداند، در این صورت "findDOMNode" گره DOM را که مربوط به اولین فرزند غیر خالی است، باز می گرداند.

> نکته:
>
> `findDOMNode` فقط روی کامپوننت‌هایی که mount شده اند کار می‌کنند (که آن کامپوننت در جای خود در DOM قرار گرفته است). اگر سعی کنید که آن را در کامپوننت فراخوانی کنید که هنوز در صفحه mount نشده است (مثل فراخوانی  `findDOMNode()` در `render()` روی کامپوننتی که هنوز ایجاد نشده است) به exception میخورید.
>
> `findDOMNode` در کامپوننت‌های تابعی کار نمی‌کند.
</p>

* * *

<h3 dir="rtl">`createPortal()` {#createportal}</h3>

```javascript
ReactDOM.createPortal(child, container)
```

<p dir="rtl">
ایجاد یک پرتال. پورتال ها راهی برای [دادن اجزای فرزند به گره DOM که در خارج از سلسله مراتب از مؤلفه DOM وجود دارد ارائه می دهد](/docs/portalals.html).
</p>
