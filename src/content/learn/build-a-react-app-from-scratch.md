---
title: ساخت یک اپلیکیشن React از صفر
---

<Intro>

اگر اپلیکیشن شما محدودیت‌هایی دارد که فریم‌ورک‌های موجود به خوبی از آن پشتیبانی نمی‌کنند، ترجیح می‌دهید فریم‌ورک خود را بسازید، یا فقط می‌خواهید اصول اولیه یک اپلیکیشن React را یاد بگیرید، می‌توانید یک اپلیکیشن React از صفر بسازید.

</Intro>

<DeepDive>

#### استفاده از یک فریم‌ورک را در نظر بگیرید {/*consider-using-a-framework*/}

شروع از صفر یک روش آسان برای شروع استفاده از React است، اما یک مصالحه مهمی که باید بدان آگاه باشید این است که این رویکرد اغلب همانند ساخت فریم‌ورک خودسر خود است. هنگامی که نیاز‌های شما تکامل می‌یابند، ممکن است نیاز داشته باشید مسائل بیشتری مانند فریم‌ورک حل کنید که فریم‌ورک‌های توصیه شده ما قبلاً راه‌حل‌های خوب و پشتیبانی شده برای آن‌ها دارند.

برای مثال، اگر در آینده اپلیکیشن شما به پشتیبانی از رندرینگ سمت سرور (SSR)، تولید سایت ایستا (SSG)، و/یا React Server Components (RSC) نیاز داشته باشد، باید این‌ها را خود پیاده‌سازی کنید. به طور مشابه، ویژگی‌های آینده React که نیاز به ادغام در سطح فریم‌ورک دارند باید خود پیاده‌سازی شوند اگر می‌خواهید از آن‌ها استفاده کنید.

فریم‌ورک‌های توصیه شده ما همچنین به شما کمک می‌کنند اپلیکیشن‌های عملکردی بهتری بسازید. برای مثال، کاهش یا حذف آبشار‌های درخواست‌های شبکه باعث تجربه کاربری بهتری می‌شود. این ممکن است زمانی که یک پروژه اسباب‌بازی می‌سازید اولویت بالایی نباشد، اما اگر اپلیکیشن شما کاربران کسب کند، ممکن است بخواهید عملکرد آن را بهبود دهید.

این رویکرد همچنین دریافت پشتیبانی را دشوارتر می‌کند، زیرا روشی که شما مسیریابی، واکشی داده‌ها، و سایر ویژگی‌ها را توسعه می‌دهید منحصر به فرد برای شرایط شما است. شما باید این گزینه را فقط اگر احساس خود اعتماد دارید این مسائل را به تنهایی حل کنید، یا اگر مطمئن هستید که هرگز این ویژگی‌ها را نخواهید داشت، انتخاب کنید.

برای لیستی از فریم‌ورک‌های توصیه شده، [ایجاد یک اپلیکیشن React](/learn/creating-a-react-app) را بررسی کنید.

</DeepDive>


## مرحله 1: نصب یک ابزار ساخت {/*step-1-install-a-build-tool*/}

اولین مرحله نصب یک ابزار ساخت مانند `vite`، `parcel`، یا `rsbuild` است. این ابزارهای ساخت ویژگی‌هایی را برای بسته‌بندی و اجرای کد منبع، فراهم کردن سرور توسعه برای توسعه محلی و دستور ساخت برای استقرار اپلیکیشن خود بر روی سرور تولید فراهم می‌کنند.

### Vite {/*vite*/}

[Vite](https://vite.dev/) یک ابزار ساخت است که هدف آن فراهم کردن یک تجربه توسعه سریع‌تر و سبک‌تر برای پروژه‌های وب مدرن است.

<TerminalBlock>
{`npm create vite@latest my-app -- --template react`}
</TerminalBlock>

Vite نظریات خود را دارد و با پیش‌فرض‌های معقول از ابتدا می‌آید. Vite دارای اکوسیستم غنی از افزونه‌ها برای پشتیبانی از بروزرسانی سریع، JSX، Babel/SWC، و سایر ویژگی‌های متداول است. برای شروع [افزونه React](https://vite.dev/plugins/#vitejs-plugin-react) یا [افزونه React SWC](https://vite.dev/plugins/#vitejs-plugin-react-swc) و [نمونه پروژه React SSR](https://vite.dev/guide/ssr.html#example-projects) Vite را ببینید.

Vite قبلاً به عنوان ابزار ساخت در یکی از [فریم‌ورک‌های توصیه شده](/learn/creating-a-react-app) ما استفاده می‌شود: [React Router](https://reactrouter.com/start/framework/installation).

### Parcel {/*parcel*/}

[Parcel](https://parceljs.org/) یک تجربه توسعه فوق‌العاده خارج از جعبه را با معماری مقیاس‌پذیر ترکیب می‌کند که می‌تواند پروژه شما را از تازه شروع تا اپلیکیشن‌های تولید عظیم ببرد.

<TerminalBlock>
{`npm install --save-dev parcel`}
</TerminalBlock>

Parcel از بروزرسانی سریع، JSX، TypeScript، Flow، و استایل‌دهی خارج از جعبه پشتیبانی می‌کند. برای شروع [دستور React](https://parceljs.org/recipes/react/#getting-started) Parcel را ببینید.

### Rsbuild {/*rsbuild*/}

[Rsbuild](https://rsbuild.dev/) یک ابزار ساخت با قدرت Rspack است که یک تجربه توسعه بدون مانع برای اپلیکیشن‌های React فراهم می‌کند. با پیش‌فرض‌های دقیق‌تر تنظیم شده و بهینه‌سازی‌های عملکرد آماده برای استفاده می‌آید.

<TerminalBlock>
{`npx create-rsbuild --template react`}
</TerminalBlock>

Rsbuild دارای پشتیبانی داخلی برای ویژگی‌های React مانند بروزرسانی سریع، JSX، TypeScript، و استایل‌دهی است. برای شروع [راهنمای React](https://rsbuild.dev/guide/framework/react) Rsbuild را ببینید.

<Note>

#### Metro برای React Native {/*react-native*/}

اگر با React Native از صفر شروع می‌کنید، باید از [Metro](https://metrobundler.dev/) استفاده کنید، بسته‌بندی‌کننده JavaScript برای React Native. Metro از بسته‌بندی برای پلتفرم‌هایی مانند iOS و Android پشتیبانی می‌کند، اما در مقایسه با ابزارهای اینجا بسیاری از ویژگی‌ها را فاقد است. ما توصیه می‌کنیم با Vite، Parcel، یا Rsbuild شروع کنید مگر اینکه پروژه شما به پشتیبانی React Native نیاز داشته باشد.

</Note>

## مرحله 2: ساخت الگوهای اپلیکیشن مشترک {/*step-2-build-common-application-patterns*/}

ابزارهای ساخت ذکر شده بالا با یک اپلیکیشن تک‌صفحه‌ای (SPA) فقط در سمت کلاینت شروع می‌شوند، اما هیچ راه‌حل بیشتری برای عملکرد مشترک مانند مسیریابی، واکشی داده، یا استایل‌دهی شامل نمی‌شوند.

اکوسیستم React شامل بسیاری از ابزارها برای این مسائل است. ما چند ابزار را که به طور گسترده‌ای به عنوان نقطه شروع استفاده می‌شوند فهرست کرده‌ایم، اما می‌توانید ابزارهای دیگری را انتخاب کنید اگر بهتر برای شما کار کنند.

### مسیریابی {/*routing*/}

مسیریابی تعیین می‌کند چه محتوا یا صفحاتی را نمایش دهید زمانی که کاربر از URL خاصی بازدید می‌کند. شما باید یک مسیریاب را تنظیم کنید تا URL‌ها را به قسمت‌های مختلف اپلیکیشن نقشه‌برداری کنید. همچنین باید مسیرهای تو‌در‌تو، پارامترهای مسیر، و پارامترهای پرس‌وجو را مدیریت کنید. مسیریابها می‌توانند در کد شما پیکربندی شوند یا بر اساس ساختار پوشه و فایل اجزای شما تعریف شوند.

مسیریابها بخش اساسی از اپلیکیشن‌های مدرن هستند، و معمولاً با واکشی داده (شامل از پیش‌واکشی داده برای یک صفحه کامل برای بارگذاری سریع‌تر)، تقسیم کد (برای کاهش اندازه بسته کلاینت)، و روش‌های رندرینگ صفحه (برای تصمیم‌گیری درباره چگونگی تولید هر صفحه) یکپارچه می‌شوند.

ما توصیه می‌کنیم استفاده کنید:

- [React Router](https://reactrouter.com/start/data/custom)
- [Tanstack Router](https://tanstack.com/router/latest)


### واکشی داده {/*data-fetching*/}

واکشی داده از یک سرور یا منبع داده دیگر بخشی کلیدی از اکثر اپلیکیشن‌ها است. انجام این کار به درستی نیاز به مدیریت حالت‌های بارگذاری، حالت‌های خطا، و ذخیره‌سازی در کش داده‌های واکشی شده دارد، که می‌تواند پیچیده باشد.

کتابخانه‌های واکشی داده‌ای ساخته شده برای این منظور کار سخت واکشی و ذخیره‌سازی در کش داده را برای شما انجام می‌دهند، به شما اجازه می‌دهند روی داده‌ای که اپلیکیشن شما نیاز دارد و چگونگی نمایش آن تمرکز کنید. این کتابخانه‌ها معمولاً مستقیماً در اجزای شما استفاده می‌شوند، اما می‌توانند همچنین در محمل‌های مسیریاب برای از پیش‌واکشی سریع‌تر و عملکرد بهتر، و در رندرینگ سرور نیز یکپارچه شوند.

توجه داشته باشید که واکشی داده مستقیم در اجزا می‌تواند به دلیل آبشار‌های درخواست شبکه باعث زمان‌های بارگذاری کندتر شود، بنابراین ما توصیه می‌کنیم تا جای ممکن در محمل‌های مسیریاب یا بر روی سرور داده را از پیش‌واکشی کنید! این امکان را می‌دهد داده‌های صفحه به یکباره و هنگام نمایش صفحه واکشی شود.

اگر داده را از اکثر بک‌اند‌ها یا API‌های سبک REST‌ واکشی می‌کنید، ما توصیه می‌کنیم:

- [React Query](https://react-query.tanstack.com/)
- [SWR](https://swr.vercel.app/)
- [RTK Query](https://redux-toolkit.js.org/rtk-query/overview)

اگر داده را از API GraphQL واکشی می‌کنید، ما توصیه می‌کنیم:

- [Apollo](https://www.apollographql.com/docs/react)
- [Relay](https://relay.dev/)


### تقسیم کد {/*code-splitting*/}

تقسیم کد فرایند شکستن اپلیکیشن شما به بسته‌های کوچک‌تری است که می‌توانند بر اساس تقاضا بارگذاری شوند. اندازه کد اپلیکیشن با هر ویژگی جدید و وابستگی اضافی افزایش می‌یابد. اپلیکیشن‌ها می‌توانند بدلیل اینکه کل کد برای کل اپلیکیشن باید قبل از استفاده ارسال شود کند بارگذاری شوند. ذخیره‌سازی در کش، کاهش ویژگی‌ها/وابستگی‌ها، و انتقال برخی کدها برای اجرا بر روی سرور می‌تواند به کاهش بارگذاری کند کمک کند اما راه‌حل‌های ناقصی هستند که می‌توانند عملکرد را قربانی کنند اگر بیش‌ازحد استفاده شوند.

به طور مشابه، اگر شما برای تقسیم کد بر روی اپلیکیشن‌هایی که فریم‌ورک شما را استفاده می‌کنند تکیه کنید، ممکن است با شرایطی مواجه شوید که بارگذاری کندتر از اگر اصلاً تقسیم کد اتفاق نمی‌افتاد باشد. برای مثال، [تنبل بارگذاری](/reference/react/lazy) یک نمودار کد مورد نیاز برای رندرینگ نمودار را تأخیر می‌دهد، کد نمودار را از بقیه اپلیکیشن جدا می‌کند. [Parcel از تقسیم کد با React.lazy پشتیبانی می‌کند](https://parceljs.org/recipes/react/#code-splitting). با این حال، اگر نمودار داده‌های خود را *بعد* از اینکه برای اولین بار رندر شد بارگذاری کند شما اکنون دو بار منتظر می‌مانید. این یک آبشار است: به جای واکشی داده نمودار و ارسال کد برای رندرینگ آن به طور همزمان، باید برای هر مرحله منتظر بمانید تا یکی پس از دیگری تکمیل شود.

تقسیم کد بر اساس مسیر، زمانی که با بسته‌بندی و واکشی داده یکپارچه شود، می‌تواند زمان بارگذاری اولیه اپلیکیشن و زمان رندرینگ بزرگ‌ترین محتوای قابل‌دیدی اپلیکیشن ([Largest Contentful Paint](https://web.dev/articles/lcp)) را کاهش دهد.

برای دستور‌العمل تقسیم کد، اسناد ابزار ساخت خود را ببینید:
- [بهینه‌سازی‌های ساخت Vite](https://vite.dev/guide/features.html#build-optimizations)
- [تقسیم کد Parcel](https://parceljs.org/features/code-splitting/)
- [تقسیم کد Rsbuild](https://rsbuild.dev/guide/optimization/code-splitting)

### بهبود عملکرد اپلیکیشن {/*improving-application-performance*/}

از آنجایی که ابزار ساخت انتخابی شما فقط از اپلیکیشن‌های تک‌صفحه‌ای (SPA) پشتیبانی می‌کند، باید سایر [الگوهای رندرینگ](https://www.patterns.dev/vanilla/rendering-patterns) مانند رندرینگ سمت سرور (SSR)، تولید سایت ایستا (SSG)، و/یا React Server Components (RSC) پیاده‌سازی کنید. حتی اگر در ابتدا به این ویژگی‌ها نیاز نداشته باشید، در آینده ممکن است مسیرهایی وجود داشته باشند که از SSR، SSG یا RSC سود ببرند.

* **اپلیکیشن‌های تک‌صفحه‌ای (SPA)** یک صفحه HTML را بارگذاری می‌کنند و صفحه را به طور پویا هنگام تعامل کاربر با اپلیکیشن به روزرسانی می‌کنند. SPA‌ها شروع شدن آسان‌تری دارند، اما می‌توانند زمان‌های بارگذاری اولیه کندتری داشته باشند. SPA‌ها معماری پیش‌فرض برای اکثر ابزارهای ساخت هستند.

* **رندرینگ سمت سرور با جریان (SSR)** یک صفحه را روی سرور رندر می‌کند و صفحه کاملاً رندر شده را به کلاینت ارسال می‌کند. SSR می‌تواند عملکرد را بهبود دهد، اما می‌تواند تنظیم و نگهداری آن نسبت به یک اپلیکیشن تک‌صفحه‌ای پیچیده‌تر باشد. با افزودن جریان، SSR می‌تواند بسیار پیچیده برای تنظیم و نگهداری باشد. [راهنمای SSR Vite](https://vite.dev/guide/ssr) را ببینید.

* **تولید سایت ایستا (SSG)** فایل‌های HTML ایستا برای اپلیکیشن شما را در زمان ساخت تولید می‌کند. SSG می‌تواند عملکرد را بهبود دهد، اما می‌تواند تنظیم و نگهداری آن نسبت به رندرینگ سمت سرور پیچیده‌تر باشد. [راهنمای SSG Vite](https://vite.dev/guide/ssr.html#pre-rendering-ssg) را ببینید.

* **React Server Components (RSC)** به شما اجازه می‌دهد ترکیب اجزای زمان ساخت، فقط سرور، و تعاملی در یک درخت React واحد کنید. RSC می‌تواند عملکرد را بهبود دهد، اما در حال حاضر به تخصص عمیق برای تنظیم و نگهداری نیاز دارد. [نمونه‌های RSC Parcel](https://github.com/parcel-bundler/rsc-examples) را ببینید.

استراتژی‌های رندرینگ شما باید با مسیریاب شما یکپارچه شوند تا اپلیکیشن‌هایی که با فریم‌ورک شما ساخته شده‌اند بتوانند استراتژی رندرینگ را در سطح هر مسیر انتخاب کنند. این امر امکان استراتژی‌های رندرینگ متفاوت را فراهم می‌کند بدون اینکه مجبور باشید کل اپلیکیشن خود را بازنویسی کنید. برای مثال، صفحه فرودی اپلیکیشن شما ممکن است از تولید ایستا (SSG) سود ببرد، در حالی که صفحه‌ای با یک خوراک محتوا ممکن است با رندرینگ سمت سرور بهترین عملکرد داشته باشد.

استفاده از استراتژی رندرینگ صحیح برای مسیرهای صحیح می‌تواند زمان را برای اولین بایت محتوا بارگذاری شده ([Time to First Byte](https://web.dev/articles/ttfb))، اولین قطعه محتوا رندر شده ([First Contentful Paint](https://web.dev/articles/fcp))، و بزرگ‌ترین محتوای قابل‌دیدی اپلیکیشن رندر شده ([Largest Contentful Paint](https://web.dev/articles/lcp)) کاهش دهد.

### و بیشتر... {/*and-more*/}

اینها فقط چند نمونه از ویژگی‌هایی هستند که یک اپلیکیشن جدید هنگام ساخت از صفر باید در نظر بگیرد. بسیاری از محدودیت‌هایی که با آن‌ها مواجه خواهید شد می‌توانند حل شدن دشواری باشند زیرا هر مسئله با سایر مسائل با هم مرتبط است و می‌تواند به تخصص عمیق در حوزه‌های مسائلی نیاز داشته باشند که ممکن است با آن‌ها آشنا نباشید.

اگر نمی‌خواهید این مسائل را خود حل کنید، می‌توانید [با یک فریم‌ورک شروع کنید](/learn/creating-a-react-app) که این ویژگی‌ها را خارج از جعبه فراهم می‌کند.