---
title: ساخت یک برنامه ری‌اکت از ابتدا
---

<Intro>

اگر برنامه شما محدودیت‌هایی دارد که توسط فریم‌ورک‌های موجود به خوبی پشتیبانی نمی‌شود، ترجیح می‌دهید فریم‌ورک خود را بسازید، یا فقط می‌خواهید اصول اولیه یک برنامه ری‌اکت را یاد بگیرید، می‌توانید یک برنامه ری‌اکت را از ابتدا بسازید.

</Intro>

<DeepDive>

#### استفاده از یک فریم‌ورک را در نظر بگیرید {/*consider-using-a-framework*/}

شروع از ابتدا راهی آسان برای شروع استفاده از ری‌اکت است، اما یک مصالحه مهم که باید از آن آگاه باشید این است که این مسیر اغلب مانند ساخت فریم‌ورک موقت خودتان است. با تکامل نیازهای شما، ممکن است لازم باشد مشکلات شبیه به فریم‌ورک را حل کنید که فریم‌ورک‌های توصیه شده ما قبلاً راه‌حل‌های توسعه‌یافته و پشتیبانی‌شده برای آنها دارند.

به عنوان مثال، اگر در آینده برنامه شما نیاز به پشتیبانی از رندر سمت سرور (SSR)، تولید سایت استاتیک (SSG)، و/یا کامپوننت‌های سرور ری‌اکت (RSC) داشته باشد، باید آنها را خودتان پیاده‌سازی کنید. به طور مشابه، قابلیت‌های آینده ری‌اکت که نیاز به یکپارچه‌سازی در سطح فریم‌ورک دارند، باید توسط خودتان پیاده‌سازی شوند اگر می‌خواهید از آنها استفاده کنید.

فریم‌ورک‌های توصیه شده ما همچنین به شما کمک می‌کنند برنامه‌های با عملکرد بهتری بسازید. به عنوان مثال، کاهش یا حذف آبشارهای درخواست‌های شبکه باعث تجربه کاربری بهتری می‌شود. این ممکن است هنگام ساخت یک پروژه آزمایشی اولویت بالایی نباشد، اما اگر برنامه شما کاربران بیشتری پیدا کند، ممکن است بخواهید عملکرد آن را بهبود دهید.

رفتن به این مسیر همچنین دریافت پشتیبانی را دشوارتر می‌کند، زیرا نحوه توسعه مسیریابی، واکشی داده و سایر قابلیت‌ها منحصر به وضعیت شما خواهد بود. شما فقط باید این گزینه را انتخاب کنید اگر در مورد حل این مشکلات به تنهایی راحت هستید، یا اگر اطمینان دارید که هرگز به این قابلیت‌ها نیاز نخواهید داشت.

برای لیستی از فریم‌ورک‌های توصیه شده، [ساخت یک برنامه ری‌اکت](/learn/creating-a-react-app) را بررسی کنید.

</DeepDive>


## گام 1: نصب یک ابزار ساخت {/*step-1-install-a-build-tool*/}

اولین گام نصب یک ابزار ساخت مانند `vite`، `parcel` یا `rsbuild` است. این ابزارهای ساخت قابلیت‌هایی را برای بسته‌بندی و اجرای کد منبع، ارائه یک سرور توسعه برای توسعه محلی و یک دستور ساخت برای استقرار برنامه شما در یک سرور تولید فراهم می‌کنند.

### Vite {/*vite*/}

[Vite](https://vite.dev/) یک ابزار ساخت است که هدف آن ارائه یک تجربه توسعه سریع‌تر و سبک‌تر برای پروژه‌های وب مدرن است.

<TerminalBlock>
{`npm create vite@latest my-app -- --template react`}
</TerminalBlock>

Vite دارای نظر قطعی است و با تنظیمات پیش‌فرض منطقی از ابتدا ارائه می‌شود. Vite دارای یک اکوسیستم غنی از پلاگین‌ها برای پشتیبانی از بازسازی سریع، JSX، Babel/SWC و سایر قابلیت‌های رایج است. برای شروع، [پلاگین React](https://vite.dev/plugins/#vitejs-plugin-react) یا [پلاگین React SWC](https://vite.dev/plugins/#vitejs-plugin-react-swc) و [پروژه نمونه React SSR](https://vite.dev/guide/ssr.html#example-projects) را ببینید.

Vite در حال حاضر به عنوان یک ابزار ساخت در یکی از [فریم‌ورک‌های توصیه شده](/learn/creating-a-react-app) ما استفاده می‌شود: [React Router](https://reactrouter.com/start/framework/installation).

### Parcel {/*parcel*/}

[Parcel](https://parceljs.org/) تجربه توسعه عالی از ابتدا را با معماری مقیاس‌پذیری ترکیب می‌کند که می‌تواند پروژه شما را از شروع تا برنامه‌های تولیدی بزرگ هدایت کند.

<TerminalBlock>
{`npm install --save-dev parcel`}
</TerminalBlock>

Parcel از بازسازی سریع، JSX، TypeScript، Flow و استایل‌دهی از ابتدا پشتیبانی می‌کند. برای شروع، [دستور العمل React Parcel](https://parceljs.org/recipes/react/#getting-started) را ببینید.

### Rsbuild {/*rsbuild*/}

[Rsbuild](https://rsbuild.dev/) یک ابزار ساخت مبتنی بر Rspack است که تجربه توسعه یکپارچه‌ای برای برنامه‌های ری‌اکت فراهم می‌کند. این ابزار با تنظیمات پیش‌فرض دقیق و بهینه‌سازی‌های عملکرد آماده استفاده ارائه می‌شود.

<TerminalBlock>
{`npx create-rsbuild --template react`}
</TerminalBlock>

Rsbuild شامل پشتیبانی داخلی برای قابلیت‌های ری‌اکت مانند بازسازی سریع، JSX، TypeScript و استایل‌دهی است. برای شروع، [راهنمای React Rsbuild](https://rsbuild.dev/guide/framework/react) را ببینید.

<Note>

#### Metro برای React Native {/*react-native*/}

اگر با React Native از ابتدا شروع می‌کنید، باید از [Metro](https://metrobundler.dev/)، بسته‌بند JavaScript برای React Native استفاده کنید. Metro از بسته‌بندی برای پلتفرم‌هایی مانند iOS و Android پشتیبانی می‌کند، اما در مقایسه با ابزارهای اینجا بسیاری از قابلیت‌ها را ندارد. ما توصیه می‌کنیم با Vite، Parcel یا Rsbuild شروع کنید مگر اینکه پروژه شما نیاز به پشتیبانی React Native داشته باشد.

</Note>

## گام 2: ساخت الگوهای رایج برنامه {/*step-2-build-common-application-patterns*/}

ابزارهای ساخت ذکر شده در بالا با یک برنامه تک‌صفحه‌ای (SPA) فقط سمت کلاینت شروع می‌شوند، اما راه‌حل‌های بیشتری برای عملکردهای رایج مانند مسیریابی، واکشی داده یا استایل‌دهی ارائه نمی‌دهند.

اکوسیستم ری‌اکت شامل بسیاری از ابزارها برای این مشکلات است. ما چند مورد که به طور گسترده به عنوان نقطه شروع استفاده می‌شوند را فهرست کرده‌ایم، اما اگر ابزارهای دیگری برای شما بهتر کار می‌کنند، آزادانه از آنها استفاده کنید.

### مسیریابی {/*routing*/}

مسیریابی تعیین می‌کند که چه محتوا یا صفحاتی هنگامی که کاربر از یک URL خاص بازدید می‌کند، نمایش داده شود. شما باید یک مسیریاب راه‌اندازی کنید تا URLها را به بخش‌های مختلف برنامه خود نگاشت کنید. همچنین باید مسیرهای تو در تو، پارامترهای مسیر و پارامترهای پرس‌وجو را مدیریت کنید. مسیریاب‌ها می‌توانند در کد شما پیکربندی شوند یا بر اساس ساختار پوشه و فایل کامپوننت شما تعریف شوند.

مسیریاب‌ها بخش اصلی برنامه‌های مدرن هستند و معمولاً با واکشی داده (از جمله پیش‌واکشی داده برای یک صفحه کامل برای بارگذاری سریع‌تر)، تقسیم کد (برای به حداقل رساندن اندازه بسته کلاینت) و رویکردهای رندر صفحه (برای تصمیم‌گیری در مورد نحوه تولید هر صفحه) یکپارچه می‌شوند.

ما پیشنهاد می‌کنیم از موارد زیر استفاده کنید:

- [React Router](https://reactrouter.com/start/data/custom)
- [Tanstack Router](https://tanstack.com/router/latest)


### واکشی داده {/*data-fetching*/}

واکشی داده از یک سرور یا منبع داده دیگر بخش کلیدی اکثر برنامه‌ها است. انجام صحیح این کار نیاز به مدیریت وضعیت‌های بارگذاری، وضعیت‌های خطا و ذخیره‌سازی داده‌های واکشی شده دارد، که می‌تواند پیچیده باشد.

کتابخانه‌های واکشی داده هدفمند، کار سخت واکشی و ذخیره‌سازی داده را برای شما انجام می‌دهند و به شما اجازه می‌دهند تا روی داده‌هایی که برنامه شما نیاز دارد و نحوه نمایش آنها تمرکز کنید. این کتابخانه‌ها معمولاً مستقیماً در کامپوننت‌های شما استفاده می‌شوند، اما می‌توانند در لودرهای مسیریابی برای پیش‌واکشی سریع‌تر و عملکرد بهتر، و همچنین در رندر سرور یکپارچه شوند.

توجه داشته باشید که واکشی داده مستقیماً در کامپوننت‌ها می‌تواند به دلیل آبشارهای درخواست شبکه منجر به زمان‌های بارگذاری کندتری شود، بنابراین ما توصیه می‌کنیم تا حد امکان داده را در لودرهای مسیریاب یا در سرور پیش‌واکشی کنید! این اجازه می‌دهد داده‌های یک صفحه همه با هم واکشی شوند زمانی که صفحه در حال نمایش است.

اگر داده را از اکثر بک‌اندها یا APIهای سبک REST واکشی می‌کنید، ما پیشنهاد می‌کنیم از موارد زیر استفاده کنید:

- [React Query](https://react-query.tanstack.com/)
- [SWR](https://swr.vercel.app/)
- [RTK Query](https://redux-toolkit.js.org/rtk-query/overview)

اگر داده را از یک API GraphQL واکشی می‌کنید، ما پیشنهاد می‌کنیم از موارد زیر استفاده کنید:

- [Apollo](https://www.apollographql.com/docs/react)
- [Relay](https://relay.dev/)


### تقسیم کد {/*code-splitting*/}

تقسیم کد فرآیند شکستن برنامه شما به بسته‌های کوچکتری است که می‌توانند در صورت نیاز بارگذاری شوند. اندازه کد یک برنامه با هر قابلیت جدید و وابستگی اضافی افزایش می‌یابد. برنامه‌ها می‌توانند کند شوند زیرا تمام کد برای کل برنامه باید قبل از استفاده ارسال شود. ذخیره‌سازی، کاهش قابلیت‌ها/وابستگی‌ها و انتقال برخی کدها برای اجرا در سرور می‌تواند به کاهش بارگذاری کند کمک کند اما راه‌حل‌های ناقصی هستند که در صورت استفاده بیش از حد می‌توانند عملکرد را فدا کنند.

به طور مشابه، اگر به برنامه‌هایی که از فریم‌ورک شما استفاده می‌کنند برای تقسیم کد متکی باشید، ممکن است با مواردی مواجه شوید که بارگذاری کندتر از زمانی است که هیچ تقسیم کدی انجام نمی‌شد. به عنوان مثال، [بارگذاری تنبل](/reference/react/lazy) یک نمودار، ارسال کد مورد نیاز برای رندر نمودار را به تأخیر می‌اندازد و کد نمودار را از بقیه برنامه جدا می‌کند. [Parcel از تقسیم کد با React.lazy پشتیبانی می‌کند](https://parceljs.org/recipes/react/#code-splitting). با این حال، اگر نمودار داده‌های خود را *پس از* رندر اولیه بارگذاری کند، اکنون دو بار منتظر می‌مانید. این یک آبشار است: به جای واکشی همزمان داده‌های نمودار و ارسال کد برای رندر آن، باید منتظر تکمیل هر مرحله یکی پس از دیگری باشید.

تقسیم کد بر اساس مسیر، هنگامی که با بسته‌بندی و واکشی داده یکپارچه می‌شود، می‌تواند زمان بارگذاری اولیه برنامه شما و زمان رندر بزرگترین محتوای قابل مشاهده برنامه را کاهش دهد ([Largest Contentful Paint](https://web.dev/articles/lcp)).

برای دستورالعمل‌های تقسیم کد، به اسناد ابزار ساخت خود مراجعه کنید:
- [بهینه‌سازی‌های ساخت Vite](https://vite.dev/guide/features.html#build-optimizations)
- [تقسیم کد Parcel](https://parceljs.org/features/code-splitting/)
- [تقسیم کد Rsbuild](https://rsbuild.dev/guide/optimization/code-splitting)

### بهبود عملکرد برنامه {/*improving-application-performance*/}

از آنجا که ابزار ساخت انتخابی شما فقط از برنامه‌های تک‌صفحه‌ای (SPA) پشتیبانی می‌کند، باید [الگوهای رندر](https://www.patterns.dev/vanilla/rendering-patterns) دیگری مانند رندر سمت سرور (SSR)، تولید سایت استاتیک (SSG) و/یا کامپوننت‌های سرور ری‌اکت (RSC) را پیاده‌سازی کنید. حتی اگر در ابتدا به این قابلیت‌ها نیاز ندارید، در آینده ممکن است برخی مسیرها از SSR، SSG یا RSC بهره‌مند شوند.

* **برنامه‌های تک‌صفحه‌ای (SPA)** یک صفحه HTML واحد را بارگذاری می‌کنند و به صورت پویا صفحه را هنگام تعامل کاربر با برنامه به‌روز می‌کنند. SPAها شروع آسان‌تری دارند، اما می‌توانند زمان بارگذاری اولیه کندتری داشته باشند. SPAها معماری پیش‌فرض برای اکثر ابزارهای ساخت هستند.

* **رندر سمت سرور با استریمینگ (SSR)** یک صفحه را در سرور رندر می‌کند و صفحه کاملاً رندر شده را به کلاینت ارسال می‌کند. SSR می‌تواند عملکرد را بهبود بخشد، اما راه‌اندازی و نگهداری آن می‌تواند پیچیده‌تر از یک برنامه تک‌صفحه‌ای باشد. با افزودن استریمینگ، SSR می‌تواند بسیار پیچیده برای راه‌اندازی و نگهداری باشد. [راهنمای SSR Vite](https://vite.dev/guide/ssr) را ببینید.

* **تولید سایت استاتیک (SSG)** فایل‌های HTML استاتیک را برای برنامه شما در زمان ساخت تولید می‌کند. SSG می‌تواند عملکرد را بهبود بخشد، اما راه‌اندازی و نگهداری آن می‌تواند پیچیده‌تر از رندر سمت سرور باشد. [راهنمای SSG Vite](https://vite.dev/guide/ssr.html#pre-rendering-ssg) را ببینید.

* **کامپوننت‌های سرور ری‌اکت (RSC)** به شما امکان می‌دهد کامپوننت‌های زمان ساخت، فقط سرور و تعاملی را در یک درخت ری‌اکت واحد ترکیب کنید. RSC می‌تواند عملکرد را بهبود بخشد، اما در حال حاضر نیاز به تخصص عمیق برای راه‌اندازی و نگهداری دارد. [نمونه‌های RSC Parcel](https://github.com/parcel-bundler/rsc-examples) را ببینید.

استراتژی‌های رندر شما باید با مسیریاب شما یکپارچه شوند تا برنامه‌های ساخته شده با فریم‌ورک شما بتوانند استراتژی رندر را در سطح مسیر انتخاب کنند. این امکان استراتژی‌های رندر مختلف را بدون نیاز به بازنویسی کل برنامه فراهم می‌کند. به عنوان مثال، صفحه اصلی برنامه شما ممکن است از تولید استاتیک (SSG) بهره‌مند شود، در حالی که یک صفحه با فید محتوا ممکن است با رندر سمت سرور بهترین عملکرد را داشته باشد.

استفاده از استراتژی رندر مناسب برای مسیرهای مناسب می‌تواند زمان لازم برای بارگذاری اولین بایت محتوا ([Time to First Byte](https://web.dev/articles/ttfb))، اولین قطعه محتوا برای رندر ([First Contentful Paint](https://web.dev/articles/fcp)) و بزرگترین محتوای قابل مشاهده برنامه برای رندر ([Largest Contentful Paint](https://web.dev/articles/lcp)) را کاهش دهد.

### و بیشتر... {/*and-more*/}

اینها فقط چند نمونه از قابلیت‌هایی هستند که یک برنامه جدید هنگام ساخت از ابتدا باید در نظر بگیرد. بسیاری از محدودیت‌هایی که با آنها مواجه خواهید شد می‌توانند حل آنها دشوار باشد زیرا هر مشکل با دیگری مرتبط است و ممکن است نیاز به تخصص عمیق در زمینه‌های مشکلی داشته باشد که ممکن است با آنها آشنا نباشید.

اگر نمی‌خواهید این مشکلات را به تنهایی حل کنید، می‌توانید [با یک فریم‌ورک شروع کنید](/learn/creating-a-react-app) که این قابلیت‌ها را از ابتدا ارائه می‌دهد.